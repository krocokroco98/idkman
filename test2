------------------------------------------
----- =======[ Load WindUI ]
-------------------------------------------

local Version = "1.6.45"
local WindUI = loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/download/" .. Version .. "/main.lua"))()

-------------------------------------------
----- =======[ GLOBAL & CORE FUNCTIONS ]
-------------------------------------------

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local HttpService = game:GetService("HttpService")
local player = Players.LocalPlayer

-- Safe require helper from Rayfield version
local function safeRequire(pathTbl)
    local ptr = ReplicatedStorage
    for _, seg in ipairs(pathTbl) do
        ptr = ptr:FindFirstChild(seg)
        if not ptr then return nil end
    end
    local ok, mod = pcall(require, ptr)
    return ok and mod or nil
end

-- Initialize controllers and utilities
local FishingController = safeRequire({"Controllers","FishingController"})
local AnimationController = safeRequire({"Controllers","AnimationController"})
local Replion = safeRequire({"Packages","Replion"}) or safeRequire({"Packages","replion"})
local ItemUtility = safeRequire({"Shared","ItemUtility"})
-- NEW: Added for Auto-Buy Bait feature
local PlayerStatsUtility = safeRequire({"Shared", "PlayerStatsUtility"})


-- Net folder helper from Rayfield version
local function getNetFolder()
    local packages = ReplicatedStorage:WaitForChild("Packages", 10)
    if not packages then return nil end
    local index = packages:FindFirstChild("_Index")
    if index then
        for _, child in ipairs(index:GetChildren()) do
            if child.Name:match("^sleitnick_net@") then
                return child:FindFirstChild("net")
            end
        end
    end
    return ReplicatedStorage:FindFirstChild("net") or ReplicatedStorage:FindFirstChild("Net")
end

-- NEW: Helper function for formatting price (used in Auto-Buy)
local function formatPrice(price)
    if not price then return "0 Coins" end
    if price >= 1000000 then
        return string.format("%.1fM Coins", price / 1000000):gsub("%.0M", "M")
    elseif price >= 1000 then
        return string.format("%dk Coins", price / 1000)
    else
        return tostring(price) .. " Coins"
    end
end

-- =========================
-- STATE MANAGEMENT
-- =========================
local state = {
    AutoFish = false,
    AutoFavourite = false,
    AutoSell = false,
    -- NEW States for new features
    AutoEnchant = false,
    AutoBuyNextRod = false,
    AutoBuyNextBait = false,
    AutoTPEvent = false,
}
local lastFarmPosition = nil
local lastCatchTimestamp = 0
local respawnTimerLoop = nil

-- Include Legendary, Mythic, Secret fish
local allowedTiers = { [5]=true, [6]=true, [7]=true }

-- Weather Feature State
local weatherActive = {}
local weatherData = {
    ["Storm"] = { duration = 900 },
    ["Cloudy"] = { duration = 900 },
    ["Snow"] = { duration = 900 },
    ["Wind"] = { duration = 900 }
}

-- NEW: State for Visual Stats
local statValues = { FishingLuck = nil, ShinyChance = nil, MutationChance = nil }

-------------------------------------------
----- =======[ NOTIFY FUNCTION ]
-------------------------------------------

local function NotifySuccess(title, message, duration)
    WindUI:Notify({ Title = title, Content = message, Duration = duration or 5, Icon = "circle-check" })
end

local function NotifyError(title, message, duration)
    WindUI:Notify({ Title = title, Content = message, Duration = duration or 5, Icon = "ban" })
end

local function NotifyInfo(title, message, duration)
    WindUI:Notify({ Title = title, Content = message, Duration = duration or 5, Icon = "info" })
end

local function NotifyWarning(title, message, duration)
    WindUI:Notify({ Title = title, Content = message, Duration = duration or 5, Icon = "triangle-alert" })
end

-- =========================
-- FPS BOOST FUNCTION
-- =========================
local fpsBoostActive = false
local function activateFpsBoost()
    if fpsBoostActive then return end

    pcall(function()
        for _, v in pairs(game:GetDescendants()) do
            if v:IsA("BasePart") then
                v.Material = Enum.Material.SmoothPlastic
                v.Reflectance = 0
            elseif v:IsA("Decal") or v:IsA("Texture") then
                v.Transparency = 1
            end
        end

        local Lighting = game:GetService("Lighting")
        for _, effect in pairs(Lighting:GetChildren()) do
            if effect:IsA("PostEffect") then
                effect.Enabled = false
            end
        end

        Lighting.GlobalShadows = false
        Lighting.FogEnd = 1e10
        settings().Rendering.QualityLevel = "Level01"
    end)
    
    NotifyInfo("Performance", "FPS Boost activated for smooth farming.")
    fpsBoostActive = true
end


-- =========================
-- AUTO FAVOURITE
-- =========================
local function startAutoFavourite()
    task.spawn(function()
        while state.AutoFavourite do
            pcall(function()
                if not Replion or not ItemUtility then return end
                local netFolder = getNetFolder()
                local favoriteRemote = netFolder and netFolder:FindFirstChild("RE/FavoriteItem")
                if not favoriteRemote then return end

                local DataReplion = Replion.Client:WaitReplion("Data")
                local items = DataReplion and DataReplion:Get({"Inventory","Items"})
                if type(items) ~= "table" then return end
                for _, item in ipairs(items) do
                    local base = ItemUtility:GetItemData(item.Id)
                    if base and base.Data and allowedTiers[base.Data.Tier] and not item.Favorited then
                        favoriteRemote:FireServer(item.UUID)
                        item.Favorited = true
                    end
                end
            end)
            task.wait(5)
        end
    end)
end

-- =========================
-- AUTO SELL
-- =========================
local lastSellTime = 0
local AUTO_SELL_THRESHOLD = 60
local AUTO_SELL_DELAY = 60

local function startAutoSell()
    task.spawn(function()
        while state.AutoSell do
            pcall(function()
                if not Replion then return end
                local DataReplion = Replion.Client:WaitReplion("Data")
                local items = DataReplion and DataReplion:Get({"Inventory","Items"})
                if type(items) ~= "table" then return end

                local unfavoritedCount = 0
                for _, item in ipairs(items) do
                    if not item.Favorited then
                        unfavoritedCount = unfavoritedCount + (item.Count or 1)
                    end
                end

                if unfavoritedCount >= AUTO_SELL_THRESHOLD and os.time() - lastSellTime >= AUTO_SELL_DELAY then
                    local netFolder = getNetFolder()
                    if netFolder then
                        local sellFunc = netFolder:FindFirstChild("RF/SellAllItems")
                        if sellFunc then
                            task.spawn(sellFunc.InvokeServer, sellFunc)
                            lastSellTime = os.time()
                        end
                    end
                end
            end)
            task.wait(10)
        end
    end)
end

-- =========================
-- AUTO FISH V3
-- =========================
local autoFishLoop
local function playCastAnim()
    pcall(function()
        if AnimationController and AnimationController.PlayAnimation then
            AnimationController:PlayAnimation("CastFromFullChargePosition1Hand")
        end
    end)
end

local function startAutoFish()
    activateFpsBoost()
    if autoFishLoop then task.cancel(autoFishLoop) end
    if respawnTimerLoop then task.cancel(respawnTimerLoop) end

    lastCatchTimestamp = os.time()

    respawnTimerLoop = task.spawn(function()
        while state.AutoFish do
            if os.time() - lastCatchTimestamp > 60 then
                NotifyWarning("Anti-Stuck Triggered", "No fish caught in 1 minute. Resetting character...")
                if player.Character then
                    player.Character:BreakJoints()
                end
                lastCatchTimestamp = os.time()
            end
            task.wait(1)
        end
    end)

    autoFishLoop = task.spawn(function()
        local net = getNetFolder(); if not net then return end
        local equipEvent = net:WaitForChild("RE/EquipToolFromHotbar")
        local chargeFunc = net:WaitForChild("RF/ChargeFishingRod")
        local startMini  = net:WaitForChild("RF/RequestFishingMinigameStarted")
        local complete   = net:WaitForChild("RE/FishingCompleted")

        while state.AutoFish do
            if FishingController and FishingController.OnCooldown and FishingController:OnCooldown() then
                repeat task.wait(0.2) until not (FishingController:OnCooldown()) or not state.AutoFish
            end
            if not state.AutoFish then break end

            pcall(function()
                playCastAnim()
                equipEvent:FireServer(1)
                task.wait(0.1)
                chargeFunc:InvokeServer(workspace:GetServerTimeNow())
                task.wait(0.1)
                startMini:InvokeServer(-0.75, 1)

                pcall(function()
                    if AnimationController and AnimationController.PlayAnimation then
                        AnimationController:PlayAnimation("Reel")
                    end
                end)
                task.wait(0.2)
                
                for i=1,20 do
                    complete:FireServer()
                    task.wait(0.05)
                end
            end)

            local t = os.clock()
            while os.clock() - t < 0.7 and state.AutoFish do task.wait() end
        end
    end)
end

local function stopAutoFish()
    if autoFishLoop then task.cancel(autoFishLoop); autoFishLoop = nil end
    if respawnTimerLoop then task.cancel(respawnTimerLoop); respawnTimerLoop = nil end
end

-- =========================
-- AUTO BUY WEATHER
-- =========================
local function randomDelay(min, max)
    return math.random(min * 100, max * 100) / 100
end

local function autoBuyWeather(weatherType)
    local netFolder = getNetFolder()
    if not netFolder then
        NotifyError("Auto Weather", "Could not find network folder.")
        return
    end
    
    local purchaseRemote = netFolder:FindFirstChild("RF/PurchaseWeatherEvent")
    if not purchaseRemote then
        NotifyError("Auto Weather", "Could not find PurchaseWeatherEvent remote.")
        return
    end

    task.spawn(function()
        while weatherActive[weatherType] do
            pcall(function()
                purchaseRemote:InvokeServer(weatherType)
                NotifySuccess("Weather Purchased", "Successfully activated " .. weatherType)

                task.wait(weatherData[weatherType].duration)

                local randomWait = randomDelay(1, 5)
                NotifyInfo("Waiting...", "Delay before next purchase: " .. tostring(randomWait) .. "s")
                task.wait(randomWait)
            end)
        end
    end)
end

-- =========================
-- TELEPORT FUNCTION
-- =========================
local function teleportTo(posList)
    local char = player.Character or player.CharacterAdded:Wait()
    local hrp = char:FindFirstChild("HumanoidRootPart") or char:WaitForChild("HumanoidRootPart")

    if hrp then
        local chosen
        if typeof(posList) == "table" then
            chosen = posList[math.random(1, #posList)]
        else
            chosen = posList
        end
        hrp.CFrame = chosen
    end
end

-------------------------------------------
----- =======[ RESPAWN HANDLER ]
-------------------------------------------
player.CharacterAdded:Connect(function(character)
    task.wait(2)
    if state.AutoFish and lastFarmPosition then
        NotifyInfo("Respawn Detected", "Returning to last farm location...")
        teleportTo(lastFarmPosition)
    end
end)


-------------------------------------------
----- =======[ LOAD WINDOW ]
-------------------------------------------

local Window = WindUI:CreateWindow({
    Title = "e-Fishery V1 (Enhanced)",
    Icon = "shrimp",
    Author = "by Heyji & Gemini",
    Folder = "e-Fishery",
    Size = UDim2.fromOffset(600, 450),
    Transparent = true,
    Theme = "Dark",
    KeySystem = false,
    ScrollBarEnabled = true,
    HideSearchBar = true,
    User = {
        Enabled = true,
        Anonymous = false,
        Callback = function() end,
    }
})

Window:EditOpenButton({
    Title = "e-Fishery",
    Icon = "shrimp",
    CornerRadius = UDim.new(0,19),
    StrokeThickness = 2,
    Color = ColorSequence.new(Color3.fromHex("9600FF"), Color3.fromHex("AEBAF8")),
    Draggable = true,
})

Window:Tag({ Title = "ENHANCED", Color = Color3.fromHex("#30ff6a") })
WindUI:SetNotificationLower(true)

-------------------------------------------
----- =======[ ALL TABS ]
-------------------------------------------

local Home = Window:Tab({ Title = "Developer Info", Icon = "hard-drive" })
local Main = Window:Tab({ Title = "Main", Icon = "toggle-right" })
local AutoFarm = Window:Tab({ Title = "Auto Farm", Icon = "map" })
local AutomationTab = Window:Tab({ Title = "Automation", Icon = "atom" })
local FishNotif = Window:Tab({ Title = "Fish Notification", Icon = "bell-ring" })
local TradeTab = Window:Tab({ Title = "Auto Trade", Icon = "handshake" })
local ClientTab = Window:Tab({ Title = "Client", Icon = "user" }) -- NEW TAB

-------------------------------------------
----- =======[ HOME / DEVELOPER INFO TAB ]
-------------------------------------------

local InviteAPI = "https://discord.com/api/v10/invites/"

local function LookupDiscordInvite(inviteCode)
    local url = InviteAPI .. inviteCode .. "?with_counts=true"
    local success, response = pcall(game.HttpGet, game, url)
    if success then
        local data = HttpService:JSONDecode(response)
        return {
            name = data.guild and data.guild.name or "Unknown",
            online = data.approximate_presence_count or 0,
            members = data.approximate_member_count or 0,
            icon = data.guild and data.guild.icon and "https://cdn.discordapp.com/icons/"..data.guild.id.."/"..data.guild.icon..".png" or "",
        }
    end
    return nil
end

local inviteData = LookupDiscordInvite("UyscFN7q7J")
if inviteData then
    Home:Paragraph({
        Title = string.format("[DISCORD] %s", inviteData.name),
        Desc = string.format("Members: %d\nOnline: %d", inviteData.members, inviteData.online),
        Image = inviteData.icon,
        ImageSize = 50,
        Locked = true,
    })
end

-------------------------------------------
----- =======[ CONFIG & SAVE/LOAD SYSTEM ]
-------------------------------------------
local savedData = {
    webhookUrl = "",
    autoFish = false,
    autoFavourite = false,
    autoSell = false,
    webhookCategories = {"Secret"},
    lastFarmPosition = nil
}
local file_name = "e_fishery_session.json"
local webhookUrl, SelectedCategories

local function saveConfig()
    if writefile then
        savedData.webhookUrl = webhookUrl
        savedData.autoFish = state.AutoFish
        savedData.autoFavourite = state.AutoFavourite
        savedData.autoSell = state.AutoSell
        savedData.webhookCategories = SelectedCategories
        savedData.lastFarmPosition = lastFarmPosition
        writefile(file_name, HttpService:JSONEncode(savedData))
    end
end

local function loadConfig()
    if isfile and isfile(file_name) then
        local success, data = pcall(function()
            return HttpService:JSONDecode(readfile(file_name))
        end)
        if success and type(data) == "table" then
            for k, v in pairs(data) do
                savedData[k] = v
            end
        end
    end
    webhookUrl = savedData.webhookUrl
    SelectedCategories = savedData.webhookCategories
    lastFarmPosition = savedData.lastFarmPosition
end

-------------------------------------------
----- =======[ MAIN TAB ]
-------------------------------------------

local autoFishToggle, autoFavouriteToggle, autoSellToggle

autoFishToggle = Main:Toggle({
    Title = "Auto Fish",
    Callback = function(Value)
        state.AutoFish = Value
        if Value then startAutoFish() else stopAutoFish() end
        saveConfig()
    end
})

autoFavouriteToggle = Main:Toggle({
    Title = "Auto Favourite (Legendary+)",
    Callback = function(Value)
        state.AutoFavourite = Value
        if Value then startAutoFavourite() end
        saveConfig()
    end
})

autoSellToggle = Main:Toggle({
    Title = "Auto Sell",
    Callback = function(Value)
        state.AutoSell = Value
        if Value then startAutoSell() end
        saveConfig()
    end
})

Main:Divider()
Main:Button({
    Title = "Teleport to Esoteric Island",
    Callback = function()
        local esotericPosition = CFrame.new(3231, -1303, 1401)
        teleportTo(esotericPosition)
        NotifySuccess("Teleport", "Moving to Esoteric Island...")
    end
})

-------------------------------------------
----- =======[ AUTO FARM TAB ]
-------------------------------------------
local island_locations = {
    ["Crater Islands"] = {
        CFrame.new(1066.1864, 57.2025681, 5045.5542, -0.682534158, 1.00865822e-08, 0.730853677, -5.8900711e-09, 1, -1.93017531e-08, -0.730853677, -1.74788859e-08, -0.682534158),
        CFrame.new(1057.28992, 33.0884132, 5133.79883, 0.833871782, 5.44149223e-08, 0.551958203, -6.58184218e-09, 1, -8.86416984e-08, -0.551958203, 7.02829084e-08, 0.833871782),
    },
    ["Tropical Grove"] = { CFrame.new(-2165.05469, 2.77070165, 3639.87451, -0.589090407, -3.61497356e-08, -0.808067143, -3.20645626e-08, 1, -2.13606164e-08, 0.808067143, 1.3326984e-08, -0.589090407) },
    ["Vulcano"] = { CFrame.new(-701.447937, 48.1446075, 93.1546631, -0.0770962164, 1.34335654e-08, -0.997023642, 9.84464776e-09, 1, 1.27124169e-08, 0.997023642, -8.83526763e-09, -0.0770962164) },
    ["Coral Reefs"] = { CFrame.new(-3118.39624, 2.42531538, 2135.26392, 0.92336154, -1.0069185e-07, -0.383931547, 8.0607947e-08, 1, -6.84016968e-08, 0.383931547, 3.22115596e-08, 0.92336154) },
    ["Winter"] = { CFrame.new(2036.15308, 6.54998732, 3381.88916, 0.943401575, 4.71338666e-08, -0.331652641, -3.28136842e-08, 1, 4.87781051e-08, 0.331652641, -3.51345975e-08, 0.943401575) },
    ["Machine"] = { CFrame.new(-1459.3772, 14.7103214, 1831.5188, 0.777951121, 2.52131862e-08, -0.628324807, -5.24126378e-08, 1, -2.47663063e-08, 0.628324807, 5.21991339e-08, 0.777951121) },
    ["Treasure Room"] = { CFrame.new(-3625.0708, -279.074219, -1594.57605, 0.918176472, -3.97606392e-09, -0.396171629, -1.12946204e-08, 1, -3.62128851e-08, 0.396171629, 3.77244298e-08, 0.918176472) },
    ["Sisyphus Statue"] = { CFrame.new(-3777.43433, -135.074417, -975.198975, -0.284491211, -1.02338751e-08, -0.958678663, 6.38407585e-08, 1, -2.96199456e-08, 0.958678663, -6.96293867e-08, -0.284491211) },
    ["Fisherman Island"] = { CFrame.new(-75.2439423, 3.24433279, 3103.45093, -0.996514142, -3.14880424e-08, -0.0834242329, -3.84156422e-08, 1, 8.14354024e-08, 0.0834242329, 8.43563228e-08, -0.996514142) },
}

for name, pos in pairs(island_locations) do
    AutoFarm:Button({
        Title = name,
        Callback = function()
            lastFarmPosition = pos
            teleportTo(pos)
            task.wait(0.8)
            
            state.AutoFish = true
            startAutoFish()

            if autoFishToggle then autoFishToggle:Set(true) end
            saveConfig()
        end
    })
end

-------------------------------------------
----- =======[ AUTOMATION TAB ]
-------------------------------------------

AutomationTab:Dropdown({
    Title = "Auto Buy Weather",
    Desc = "Automatically buys selected weather events when they expire.",
    Values = { "Storm", "Cloudy", "Snow", "Wind" },
    Multi = true,
    AllowNone = true,
    Callback = function(selected)
        -- Stop any weather types that were deselected
        for weatherType, active in pairs(weatherActive) do
            if active and not table.find(selected, weatherType) then
                weatherActive[weatherType] = false
                NotifyWarning("Auto Weather", "Auto buying " .. weatherType .. " has been stopped.")
            end
        end
        -- Start any new weather types that were selected
        for _, weatherType in pairs(selected) do
            if not weatherActive[weatherType] then
                weatherActive[weatherType] = true
                NotifyInfo("Auto Weather", "Auto buying " .. weatherType .. " has started!")
                autoBuyWeather(weatherType)
            end
        end
    end
})

AutomationTab:Divider()

-- =======================================
-- MERGED: AUTO TP TO WORLD EVENTS
-- =======================================
do
    local eventTPState = { selectedEvent = nil, originalPosition = nil, platform = nil, wasAutoFishing = false, isAtEvent = false }
    local eventNames = {"Ghost Worm", "Worm Hunt", "Shark Hunt", "Ghost Shark Hunt", "Shocked", "Black Hole", "Meteor Rain"}

    AutomationTab:Dropdown({
        Title = "Auto TP to Event",
        Values = eventNames,
        AllowNone = true,
        Callback = function(value) eventTPState.selectedEvent = value end
    })

    AutomationTab:Toggle({
        Title = "Enable Auto TP to Event",
        Desc = "Automatically teleports you to the selected event when it appears and returns you after.",
        Callback = function(value)
            state.AutoTPEvent = value
            if not value and eventTPState.isAtEvent then
                if player and player.Character and player.Character.PrimaryPart and eventTPState.originalPosition then
                    player.Character.PrimaryPart.CFrame = eventTPState.originalPosition
                end
                if eventTPState.platform then eventTPState.platform:Destroy() end
                eventTPState.platform = nil
                eventTPState.isAtEvent = false
            end
        end
    })

    local function findEventPart(eventName)
        local propsFolder = workspace:FindFirstChild("Props")
        if not propsFolder then return nil end
        local eventNameLower = eventName:lower()
        for _, descendant in ipairs(propsFolder:GetDescendants()) do
            if descendant.Name == "DisplayName" and descendant:IsA("TextLabel") and descendant.Text:lower() == eventNameLower then
                local currentAncestor = descendant
                while currentAncestor and currentAncestor ~= propsFolder do
                    if currentAncestor:IsA("BasePart") then return currentAncestor end
                    currentAncestor = currentAncestor.Parent
                end
            end
        end
        return nil
    end

    task.spawn(function()
        while task.wait(5) do
            if not state.AutoTPEvent or not eventTPState.selectedEvent or not player.Character or not player.Character.PrimaryPart then continue end
            local hrp = player.Character.PrimaryPart
            local eventPart = findEventPart(eventTPState.selectedEvent)
            if eventPart and not eventTPState.isAtEvent then
                eventTPState.isAtEvent = true
                eventTPState.wasAutoFishing = state.AutoFish
                if eventTPState.wasAutoFishing then autoFishToggle:Set(false) end
                eventTPState.originalPosition = hrp.CFrame
                eventTPState.platform = Instance.new("Part", workspace)
                eventTPState.platform.Name = "EventPlatform"
                eventTPState.platform.Size = Vector3.new(30, 1, 30)
                eventTPState.platform.Position = eventPart.Position + Vector3.new(0, 50, 0)
                eventTPState.platform.Anchored = true
                eventTPState.platform.Transparency = 1
                hrp.CFrame = eventTPState.platform.CFrame * CFrame.new(0, 3, 0)
                if eventTPState.wasAutoFishing then autoFishToggle:Set(true) end
            elseif not eventPart and eventTPState.isAtEvent then
                eventTPState.wasAutoFishing = state.AutoFish
                if eventTPState.wasAutoFishing then autoFishToggle:Set(false) end
                if eventTPState.platform then eventTPState.platform:Destroy(); eventTPState.platform = nil end
                hrp.CFrame = eventTPState.originalPosition
                if eventTPState.wasAutoFishing then task.wait(1); autoFishToggle:Set(true) end
                eventTPState.isAtEvent = false
            end
        end
    end)
end

AutomationTab:Divider()
-- =======================================
-- MERGED: AUTO ENCHANT
-- =======================================
do
    local autoEnchantState = { targetEnchant = nil, stoneLimit = math.huge, stonesUsed = 0 }
    local enchantStatusParagraph

    local function getEnchantmentList()
        local enchants = {}
        local success, enchantsModule = pcall(require, ReplicatedStorage:WaitForChild("Enchants"))
        if success then
            for name, data in pairs(enchantsModule) do
                if type(data) == "table" and data.Data and data.Data.Name then table.insert(enchants, data.Data.Name) end
            end
        end
        table.sort(enchants)
        return enchants
    end
    
    AutomationTab:Dropdown({
        Title = "Select Target Enchantment", Values = getEnchantmentList(), AllowNone = true,
        Callback = function(value) autoEnchantState.targetEnchant = value end
    })
    AutomationTab:Input({
        Title = "Max Enchant Stones to Use", Placeholder = "Leave empty for no limit",
        Callback = function(value)
            local num = tonumber(value)
            autoEnchantState.stoneLimit = (num and num > 0) and num or math.huge
        end
    })
    enchantStatusParagraph = AutomationTab:Paragraph({ Title = "Status", Desc = "Idle. Equip a fishing rod to start." })
    
    AutomationTab:Toggle({
        Title = "Enable Auto Enchant",
        Callback = function(value)
            state.AutoEnchant = value
            if value then
                task.spawn(function()
                    if not autoEnchantState.targetEnchant then
                        enchantStatusParagraph:SetDesc("Error: Please select a target enchantment.")
                        state.AutoEnchant = false; return
                    end
                    local function getEquippedRod()
                        local DataReplion = Replion.Client:WaitReplion("Data")
                        local equippedId = DataReplion:Get("EquippedId")
                        if not equippedId or equippedId == "" then return nil end
                        local inventory = DataReplion:Get({"Inventory", "Fishing Rods"})
                        for _, item in ipairs(inventory) do
                            if item.UUID == equippedId then return item end
                        end
                        return nil
                    end
                    local equippedRod = getEquippedRod()
                    if not equippedRod then
                        enchantStatusParagraph:SetDesc("Error: No fishing rod equipped.")
                        state.AutoEnchant = false; return
                    end
                    autoEnchantState.stonesUsed = 0
                    local applyEnchantFunc = getNetFolder() and getNetFolder():FindFirstChild("RF/ApplyEnchantment")
                    if not applyEnchantFunc then enchantStatusParagraph:SetDesc("Error: Could not find enchant function."); state.AutoEnchant = false; return end

                    while state.AutoEnchant do
                        local currentRod = getEquippedRod()
                        if not currentRod then enchantStatusParagraph:SetDesc("Stopped. Rod was unequipped."); state.AutoEnchant = false; break end
                        if autoEnchantState.stonesUsed >= autoEnchantState.stoneLimit then enchantStatusParagraph:SetDesc("Stopped. Reached stone limit."); state.AutoEnchant = false; break end
                        if currentRod.Enchantments and #currentRod.Enchantments > 0 then
                            local enchantData = ItemUtility:GetEnchantData(currentRod.Enchantments[1])
                            if enchantData and enchantData.Data.Name == autoEnchantState.targetEnchant then
                                enchantStatusParagraph:SetDesc(string.format("Success! Found '%s' after %d stones.", autoEnchantState.targetEnchant, autoEnchantState.stonesUsed))
                                state.AutoEnchant = false; break
                            end
                        end
                        autoEnchantState.stonesUsed = autoEnchantState.stonesUsed + 1
                        enchantStatusParagraph:SetDesc(string.format("Attempting... Stones used: %d", autoEnchantState.stonesUsed))
                        pcall(applyEnchantFunc.InvokeServer, applyEnchantFunc, currentRod.UUID)
                        task.wait(1.5)
                    end
                end)
            end
        end
    })
end

AutomationTab:Divider()

-- =======================================
-- MERGED: AUTO BUY NEXT ROD/BAIT
-- =======================================
do
    local nextRodToBuy, nextBaitToBuy = nil, nil
    local nextRodParagraph = AutomationTab:Paragraph({ Title = "Next Rod to Buy", Desc = "Loading..." })
    local nextBaitParagraph = AutomationTab:Paragraph({ Title = "Next Bait to Buy", Desc = "Loading..." })

    local function updateNextRodDisplay()
        if not ItemUtility or not Replion then return end
        local allRods = {}
        for _, itemModule in ipairs(ReplicatedStorage.Items:GetChildren()) do
            local s, d = pcall(require, itemModule); if s and d and d.Data and d.Data.Type == "Fishing Rods" and d.Price then table.insert(allRods, d) end
        end
        table.sort(allRods, function(a, b) return a.Price < b.Price end)
        local ownedRods = Replion.Client:WaitReplion("Data"):Get({"Inventory", "Fishing Rods"})
        local ownedRodIds = {}; for _, rod in ipairs(ownedRods or {}) do ownedRodIds[rod.Id] = true end
        nextRodToBuy = nil
        for _, rodData in ipairs(allRods) do if not ownedRodIds[rodData.Data.Id] then nextRodToBuy = rodData; break end end
        if nextRodToBuy then
            nextRodParagraph:SetDesc(string.format("Name: %s\nPrice: %s", nextRodToBuy.Data.Name, formatPrice(nextRodToBuy.Price)))
        else
            nextRodParagraph:SetDesc("All rods purchased!")
            state.AutoBuyNextRod = false
        end
    end

    local function updateNextBaitDisplay()
        if not ItemUtility or not Replion or not PlayerStatsUtility then return end
        local allBaits = ItemUtility:GetBaits(); table.sort(allBaits, function(a, b) return (a.Price or 0) < (b.Price or 0) end)
        local ownedBaits = Replion.Client:WaitReplion("Data"):Get({"Inventory", "Baits"})
        local ownedBaitIds = {}; for _, bait in ipairs(ownedBaits or {}) do ownedBaitIds[bait.Id] = true end
        nextBaitToBuy = nil
        for _, baitData in ipairs(allBaits) do if baitData.Price and not ownedBaitIds[baitData.Data.Id] then nextBaitToBuy = baitData; break end end
        if nextBaitToBuy then
            nextBaitParagraph:SetDesc(string.format("Name: %s\nPrice: %s", nextBaitToBuy.Data.Name, formatPrice(nextBaitToBuy.Price)))
        else
            nextBaitParagraph:SetDesc("All baits purchased!")
            state.AutoBuyNextBait = false
        end
    end
    
    AutomationTab:Toggle({ Title = "Auto Buy Next Rod", Callback = function(v) state.AutoBuyNextRod = v; if v then updateNextRodDisplay() end end})
    AutomationTab:Toggle({ Title = "Auto Buy Next Bait", Callback = function(v) state.AutoBuyNextBait = v; if v then updateNextBaitDisplay() end end})
    
    task.spawn(function()
        while task.wait(5) do
            if state.AutoBuyNextRod and nextRodToBuy then
                local playerCoins = Replion.Client:WaitReplion("Data"):Get("Coins")
                if playerCoins >= nextRodToBuy.Price then
                    NotifyInfo("Auto Buy", "Purchasing " .. nextRodToBuy.Data.Name)
                    getNetFolder():FindFirstChild("RF/PurchaseFishingRod"):InvokeServer(nextRodToBuy.Data.Id)
                    task.wait(2); updateNextRodDisplay()
                end
            end
            if state.AutoBuyNextBait and nextBaitToBuy then
                local playerCoins = Replion.Client:WaitReplion("Data"):Get("Coins")
                if playerCoins >= nextBaitToBuy.Price then
                    NotifyInfo("Auto Buy", "Purchasing " .. nextBaitToBuy.Data.Name)
                    getNetFolder():FindFirstChild("RF/PurchaseBait"):InvokeServer(nextBaitToBuy.Data.Id)
                    task.wait(2); updateNextBaitDisplay()
                end
            end
        end
    end)
    task.spawn(updateNextRodDisplay); task.spawn(updateNextBaitDisplay)
end

AutomationTab:Divider()

-- =======================================
-- MERGED: UNFAVORITE LOGIC
-- =======================================
do
    local selectedUnfavoriteTiers = {}
    local tierNames = {"Common", "Uncommon", "Rare", "Epic", "Legendary", "Mythic", "Secret"}
    
    local function processUnfavoriteLogic(byTier)
        if not Replion or not ItemUtility then NotifyError("Unfavorite", "Modules not loaded."); return end
        if byTier and #selectedUnfavoriteTiers == 0 then NotifyWarning("Unfavorite", "Please select tiers first."); return end

        NotifyInfo("Unfavorite", "Scanning inventory...")
        local DataReplion = Replion.Client:WaitReplion("Data")
        local inventory = DataReplion and DataReplion:Get({"Inventory","Items"})
        if not inventory then NotifyError("Unfavorite", "Could not get inventory data."); return end

        local unfavoriteQueue = {}
        for _, item in ipairs(inventory) do
            if item.Favorited then
                if byTier then
                    local base = ItemUtility:GetItemData(item.Id)
                    if base and base.Data and table.find(selectedUnfavoriteTiers, base.Data.Tier) then
                        table.insert(unfavoriteQueue, item.UUID)
                    end
                else -- Unfavorite all
                    table.insert(unfavoriteQueue, item.UUID)
                end
            end
        end

        if #unfavoriteQueue == 0 then NotifyInfo("Unfavorite", "No matching favorited items found."); return end
        
        NotifyInfo("Unfavorite", "Found " .. #unfavoriteQueue .. " items to unfavorite. Processing...")
        local favoriteRemote = getNetFolder() and getNetFolder():FindFirstChild("RE/FavoriteItem")
        if not favoriteRemote then NotifyError("Unfavorite", "Could not find remote event."); return end

        for i, uuid in ipairs(unfavoriteQueue) do
            favoriteRemote:FireServer(uuid)
            task.wait(0.2)
        end
        NotifySuccess("Unfavorite", "Process complete. " .. #unfavoriteQueue .. " items unfavorited.")
    end

    AutomationTab:Dropdown({
        Title = "Select Tiers to Unfavorite", Values = tierNames, Multi = true, AllowNone = true,
        Callback = function(selected)
            selectedUnfavoriteTiers = {}
            for _, name in ipairs(selected) do table.insert(selectedUnfavoriteTiers, reverseRarityMap[name]) end
        end
    })
    AutomationTab:Button({Title = "Unfavorite by Selected Tiers", Callback = function() processUnfavoriteLogic(true) end})
    AutomationTab:Button({Title = "Unfavorite All Items", Callback = function() processUnfavoriteLogic(false) end})
end

-------------------------------------------
----- =======[ FISH NOTIFICATION & DATA ]
-------------------------------------------
local FishDataById, VariantsByName = {}, {}
local rarityMap = {
    [1] = "Common", [2] = "Uncommon", [3] = "Rare", [4] = "Epic",
    [5] = "Legendary", [6] = "Mythic", [7] = "Secret"
}
local reverseRarityMap = {}
for tier, name in pairs(rarityMap) do
    reverseRarityMap[name] = tier
end


pcall(function()
    for _, item in ipairs(ReplicatedStorage.Items:GetChildren()) do
        local ok, data = pcall(require, item)
        if ok and data.Data and data.Data.Type == "Fishes" then
            FishDataById[data.Data.Id] = { Name = data.Data.Name, SellPrice = data.SellPrice or 0, Tier = data.Data.Tier, Icon = data.IconId or data.Data.Icon or "" }
        end
    end
    for _, v in ipairs(ReplicatedStorage.Variants:GetChildren()) do
        local ok, data = pcall(require, v)
        if ok and data.Data and data.Data.Type == "Variant" then
            VariantsByName[data.Data.Name] = data.SellMultiplier or 1
        end
    end
end)

local categoriesDropdown
FishNotif:Paragraph({
    Title = "Fish Notification",
    Color = "Green",
    Desc = [[This feature sends a notification to Discord when you catch a rare fish. Enter your full webhook URL to connect to your channel.]]
})

local function validateWebhook(url)
    if not url or url == "" then return false, "URL is empty" end
    if not url:match("^https://discord.com/api/webhooks/%d+/.+") then return false, "Invalid Discord webhook URL format." end
    local success, response = pcall(game.HttpGet, game, url)
    if not success then return false, "Failed to connect to Discord" end
    local ok, data = pcall(HttpService.JSONDecode, HttpService, response)
    if not ok or not data or not data.channel_id then return false, "Invalid" end
    return true, data.channel_id
end

FishNotif:Input({
    Title = "Webhook URL",
    Desc = "Paste your full Discord webhook URL here! It will be saved automatically.",
    Placeholder = "https://discord.com/api/webhooks/...",
    Default = savedData.webhookUrl,
    Callback = function(text)
        if text == "" then
            webhookUrl = nil
            saveConfig()
            NotifyInfo("Webhook Cleared", "Fish notifications are now disabled.")
            return
        end

        local isValid, result = validateWebhook(text)
        if isValid then
            webhookUrl = text
            saveConfig()
            NotifySuccess("Webhook Set & Saved", "Channel ID: " .. tostring(result) .. ". Fish notifications are active!")
        else
            webhookUrl = nil
            NotifyError("URL Invalid", tostring(result) .. ". Please paste the full, valid URL.")
        end
    end
})

categoriesDropdown = FishNotif:Dropdown({
    Title = "Select Fish Categories",
    Desc = "Choose which categories to send to webhook",
    Values = {"Secret", "Legendary", "Mythic", "Epic"},
    Multi = true,
    Default = {"Secret"},
    Callback = function(selected)
        SelectedCategories = selected
        saveConfig()
    end
})


-------------------------------------------
----- =======[ AUTO TRADE TAB ]
-------------------------------------------
local targetUserId = nil
local tradeActive = false
local selectedTradeCategory = "Common"

TradeTab:Input({
   Title = "Target Player",
   Desc = "Enter the Display Name or Username of the player to trade with.",
   Placeholder = "Enter player name...",
   Callback = function(displayName)
      targetUserId = nil -- Reset target on new input
      if displayName == "" then
         NotifyInfo("Trade Target Cleared", "No player is targeted for trades.")
         return
      end
      for _, p in ipairs(Players:GetPlayers()) do
         if string.lower(p.DisplayName) == string.lower(displayName) or string.lower(p.Name) == string.lower(displayName) then
            targetUserId = p.UserId
            NotifySuccess("Trade Target Set", "Targeting " .. p.Name .. " for trades.")
            return
         end
      end
      NotifyError("Trade Target Not Found", "Could not find a player with that name.", 3)
   end,
})

TradeTab:Toggle({
   Title = "Enable Item-Click Trading",
   Desc = "When enabled, clicking an item in your inventory will send a trade request instead of equipping it.",
   Callback = function(val)
      tradeActive = val
      if val then
         NotifyInfo("Trade Mode Activated", "Click an item in your inventory to trade it.")
      else
         NotifyWarning("Trade Mode Deactivated", "Item-click trading is now off.")
      end
   end,
})

TradeTab:Divider()

TradeTab:Dropdown({
    Title = "Select Category to Trade",
    Values = {"Common", "Uncommon", "Rare", "Epic", "Legendary", "Mythic", "Secret"},
    Default = "Common",
    Callback = function(selected)
        selectedTradeCategory = selected
    end
})

TradeTab:Button({
    Title = "Trade All by Category",
    Desc = "Trades all UNFAVORITED fish of the selected category to the target player. A small delay is added between each trade.",
    Callback = function()
        if not targetUserId then
            NotifyError("Trade Failed", "You must set a target player first.")
            return
        end
        if not Replion or not ItemUtility then
            NotifyError("Trade Failed", "Required modules (Replion, ItemUtility) are not available.")
            return
        end

        local targetTier = reverseRarityMap[selectedTradeCategory]
        if not targetTier then
            NotifyError("Trade Failed", "Invalid category selected.")
            return
        end

        NotifyInfo("Starting Trade", "Finding all unfavorited '" .. selectedTradeCategory .. "' fish to trade...")

        task.spawn(function()
            local itemsToTrade = {}
            local DataReplion = Replion.Client:WaitReplion("Data")
            local inventory = DataReplion and DataReplion:Get({"Inventory","Items"})
            if type(inventory) ~= "table" then return end

            for _, item in ipairs(inventory) do
                local base = ItemUtility:GetItemData(item.Id)
                if base and base.Data and base.Data.Tier == targetTier and not item.Favorited then
                    table.insert(itemsToTrade, item.UUID)
                end
            end

            if #itemsToTrade == 0 then
                NotifyWarning("No Fish Found", "No unfavorited '" .. selectedTradeCategory .. "' fish were found in your inventory.")
                return
            end

            NotifySuccess("Fish Found", "Found " .. #itemsToTrade .. " fish. Sending trade requests now...")
            
            local netFolder = getNetFolder()
            local initiateTrade = netFolder and netFolder:FindFirstChild("RF/InitiateTrade")
            if not initiateTrade then
                NotifyError("Trade Failed", "Could not find the InitiateTrade remote function.")
                return
            end

            for i, uuid in ipairs(itemsToTrade) do
                initiateTrade:InvokeServer(targetUserId, uuid)
                task.wait(0.75) -- Delay to prevent spamming the server
            end

            NotifyInfo("Trade Complete", "Finished sending all trade requests.")
        end)
    end
})

-------------------------------------------
----- =======[ CLIENT TAB - NEW ]
-------------------------------------------

ClientTab:Paragraph({ Title = "Visual Stat Editor", Desc = "These changes are only visible to you and do not affect gameplay. They will reset on rejoin."})

ClientTab:Input({ Title = "Fishing Luck", Placeholder = "Enter a number (e.g., 99999)", Callback = function(v) statValues.FishingLuck = tonumber(v) end })
ClientTab:Input({ Title = "Shiny Chance", Placeholder = "Enter a number (e.g., 99999)", Callback = function(v) statValues.ShinyChance = tonumber(v) end })
ClientTab:Input({ Title = "Mutation Chance", Placeholder = "Enter a number (e.g., 99999)", Callback = function(v) statValues.MutationChance = tonumber(v) end })

task.spawn(function()
    while task.wait(0.5) do
        if Window and Window.Destroyed then break end
        pcall(function()
            if not player or not player.PlayerGui then return end
            local function findAndSetStat(statName, statValue, formatString)
                if statValue then
                    local statTile = player.PlayerGui:FindFirstChild("Settings") and player.PlayerGui.Settings:FindFirstChild("StatTile", true)
                    if not statTile then return end
                    for _, child in ipairs(statTile:GetChildren()) do
                        if child:IsA("Frame") and child:FindFirstChild("Label") and child.Label.Text:find(statName) then
                            local labelToUpdate = child.Label
                            local newText = string.format(formatString, statName, statValue)
                            if labelToUpdate.Text ~= newText then labelToUpdate.Text = newText end
                            break
                        end
                    end
                end
            end
            findAndSetStat("Fishing Luck", statValues.FishingLuck, "%s: +%s%%")
            findAndSetStat("Shiny Chance", statValues.ShinyChance, "%s: %s%%")
            findAndSetStat("Mutation Chance", statValues.MutationChance, "%s: +%s%%")
        end)
    end
end)


-------------------------------------------
----- =======[ METAMETHOD & EVENT HOOKS ]
-------------------------------------------

local function GetRobloxImage(assetId)
    local url = "https://thumbnails.roblox.com/v1/assets?assetIds=" .. assetId .. "&size=420x420&format=Png&isCircular=false"
    local success, response = pcall(game.HttpGet, game, url)
    if success then
        local data = HttpService:JSONDecode(response)
        if data and data.data and data.data[1] and data.data[1].imageUrl then
            return data.data[1].imageUrl
        end
    end
    return nil
end

local function sendFishWebhook(fishName, rarityText, assetId, itemId, variantId)
    if not webhookUrl or webhookUrl == "" then return end
    local username = player.DisplayName
    local imageUrl = GetRobloxImage(assetId)
    if not imageUrl then return end

    local caught = player:FindFirstChild("leaderstats") and player.leaderstats:FindFirstChild("Caught")
    local rarest = player:FindFirstChild("leaderstats") and player.leaderstats:FindFirstChild("Rarest Fish")
    local basePrice = (FishDataById[itemId] and FishDataById[itemId].SellPrice or 0) * (VariantsByName[variantId] or 1)

    local data = {
        ["username"] = "e-Fishery",
        ["embeds"] = {{
            ["title"] = "Fish Caught!",
            ["description"] = string.format("Player **%s** caught a **%s** (%s)!", username, fishName, rarityText),
            ["color"] = tonumber("0x00bfff"),
            ["image"] = { ["url"] = imageUrl },
            ["fields"] = {
                { name = "Sell Price", value = tostring(basePrice), inline = true},
                { name = "Total Caught", value = tostring(caught and caught.Value or "N/A"), inline = true},
                { name = "Rarest Fish", value = tostring(rarest and rarest.Value or "N/A"), inline = true},
            },
            ["footer"] = { ["text"] = "e-Fishery Notifier | " .. os.date("%I:%M:%S %p", os.time()) }
        }}
    }
    
    local requestFunc = syn and syn.request or http and http.request or http_request or request or fluxus and fluxus.request
    if requestFunc then
        requestFunc({ Url = webhookUrl, Method = "POST", Headers = { ["Content-Type"] = "application/json" }, Body = HttpService:JSONEncode(data) })
    end
end

local REObtainedNewFishNotification = getNetFolder() and getNetFolder():FindFirstChild("RE/ObtainedNewFishNotification")
if REObtainedNewFishNotification then
    REObtainedNewFishNotification.OnClientEvent:Connect(function(itemId, _, eventData)
        lastCatchTimestamp = os.time()

        if not webhookUrl or webhookUrl == "" then return end

        pcall(function()
            local fishInfo = FishDataById[itemId]
            if not fishInfo then return end

            local rarityName = rarityMap[fishInfo.Tier] or "Unknown Rarity"
            
            local isTarget = false
            for _, category in pairs(SelectedCategories) do
                if string.lower(category) == string.lower(rarityName) then
                    isTarget = true
                    break
                end
            end

            if isTarget then
                local assetId = string.match(fishInfo.Icon or "", "%d+")
                if not assetId then return end
                
                local fishName = fishInfo.Name
                local variantId = eventData and eventData.InventoryItem and eventData.InventoryItem.Metadata and eventData.InventoryItem.Metadata.VariantId
                
                sendFishWebhook(fishName, rarityName, assetId, itemId, variantId)
            end
        end)
    end)
end

-- TRADE HOOKS
pcall(function()
    local netFolder = getNetFolder()
    if not netFolder then return end

    -- Auto Accept Trade Logic
    local RFAwaitTradeResponse = netFolder:FindFirstChild("RF/AwaitTradeResponse")
    local autoAcceptTrade = false

    if RFAwaitTradeResponse then
        RFAwaitTradeResponse.OnClientInvoke = function(fromPlayer, timeNow)
            if autoAcceptTrade then
                NotifyInfo("Trade Accepted", "Automatically accepted trade from " .. fromPlayer.Name)
                return true
            end
            return nil 
        end

        TradeTab:Toggle({
            Title = "Auto Accept All Trades",
            Desc = "Automatically accepts any incoming trade requests.",
            Callback = function(state)
                autoAcceptTrade = state
                if state then
                    NotifySuccess("Auto Accept Enabled", "Will now accept all trades.")
                else
                    NotifyWarning("Auto Accept Disabled", "You will need to manually accept trades.")
                end
            end
        })
    else
        TradeTab:Paragraph({ Title = "Auto Accept Unavailable", Desc = "Could not find the necessary remote function to enable auto-accepting trades."})
    end

    -- Item-Click Trading Logic
    local mt = getrawmetatable(game)
    if not mt or not mt.__namecall then return end
    
    local oldNamecall = mt.__namecall
    setreadonly(mt, false)

    mt.__namecall = newcclosure(function(self, ...)
        local args = {...}
        local method = getnamecallmethod()
        
        -- The hook for trading
        if tradeActive and tostring(self) == "RE/EquipItem" and method == "FireServer" then
            local uuid = args[1]
            if uuid and targetUserId then
                local initiateTrade = netFolder:FindFirstChild("RF/InitiateTrade")
                if initiateTrade then
                    initiateTrade:InvokeServer(targetUserId, uuid)
                    NotifySuccess("Trade Sent", "Sent trade request for item.")
                else
                    NotifyError("Trade Failed", "Could not find the InitiateTrade remote function.")
                end
            elseif not targetUserId then
                NotifyError("Trade Failed", "No target player is set. Please enter a player's name.")
            end
            return nil -- Prevent the original EquipItem from firing
        end

        return oldNamecall(self, unpack(args))
    end)

    setreadonly(mt, true)
end)


-------------------------------------------
----- =======[ INITIALIZE AND RESTORE SESSION ]
-------------------------------------------

local function applyLoadedState()
    if categoriesDropdown and savedData.webhookCategories then
        categoriesDropdown:Set(savedData.webhookCategories)
    end

    if savedData.autoFavourite then
        state.AutoFavourite = true
        autoFavouriteToggle:Set(true)
    end
    if savedData.autoSell then
        state.AutoSell = true
        autoSellToggle:Set(true)
    end

    if savedData.autoFish and savedData.lastFarmPosition then
        NotifyInfo("Session Restored", "Returning to your last auto-farm location...")
        teleportTo(savedData.lastFarmPosition)
        task.wait(1.5)
        
        state.AutoFish = true
        autoFishToggle:Set(true)
    elseif savedData.autoFish then
       state.AutoFish = true
       autoFishToggle:Set(true)
    end
end

loadConfig()
applyLoadedState()
